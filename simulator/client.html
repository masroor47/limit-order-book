<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stock Market Data Visualization Client</title>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #plot {
        width: 100%;
        height: 600px;
      }
      #orderbook-plot {
        width: 100%;
        height: 600px;
        display: none;
      }
      button {
        margin: 10px 0;
        padding: 10px;
      }
      .date-range {
        margin: 10px 0;
      }
      .date-range label {
        margin-right: 10px;
      }
      .date-range input {
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Bloomberg</h1>
    <div class="date-range">
      <label for="start-date">Start Date:</label>
      <input type="datetime-local" id="start-date" />
      <label for="end-date">End Date:</label>
      <input type="datetime-local" id="end-date" />
      <button id="apply-range">Apply Range</button>
    </div>
    <div id="plot"></div>
    <button id="toggle-orderbook">Show Order Book</button>
    <div id="orderbook-plot"></div>
    <script>
      // Helper function to format date for datetime-local
      function formatDateTimeLocal(date) {
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, "0");
        const dd = String(date.getDate()).padStart(2, "0");
        const hh = String(date.getHours()).padStart(2, "0");
        const min = String(date.getMinutes()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
      }

      // Initialize WebSocket connection
      const ws = new WebSocket("ws://127.0.0.1:8766");

      // Data storage for trades (assuming trades have 'timestamp' and 'price' fields)
      let tradeData = {
        x: [], // timestamps (converted to Date objects)
        y: [], // prices
      };

      // For order book
      let subscribedOrderBook = false;
      let orderBookPlotInitialized = false;
      const toggleButton = document.getElementById("toggle-orderbook");
      let showOrderBook = false;

      toggleButton.addEventListener("click", () => {
        showOrderBook = !showOrderBook;
        if (showOrderBook) {
          if (!subscribedOrderBook) {
            ws.send(JSON.stringify({ type: "subscribe_order_book" }));
            subscribedOrderBook = true;
          }
          document.getElementById("orderbook-plot").style.display = "block";
          toggleButton.textContent = "Hide Order Book";
        } else {
          if (subscribedOrderBook) {
            ws.send(JSON.stringify({ type: "unsubscribe_order_book" }));
            subscribedOrderBook = false;
          }
          document.getElementById("orderbook-plot").style.display = "none";
          toggleButton.textContent = "Show Order Book";
        }
      });

      // Date range elements
      const startDateInput = document.getElementById("start-date");
      const endDateInput = document.getElementById("end-date");
      const applyButton = document.getElementById("apply-range");

      // Load persistent range from localStorage
      const savedStart = localStorage.getItem("startDate");
      const savedEnd = localStorage.getItem("endDate");
      if (savedStart) {
        startDateInput.value = savedStart;
      }
      if (savedEnd) {
        endDateInput.value = savedEnd;
      }

      // Set default start if not saved (market open today or previous day)
      if (!startDateInput.value) {
        const now = new Date();
        let marketOpen = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          9,
          30,
          0,
          0
        );
        if (marketOpen > now) {
          marketOpen.setDate(marketOpen.getDate() - 1);
        }
        startDateInput.value = formatDateTimeLocal(marketOpen);
      }

      // Function to request data for a given range
      function requestHistorical(fromTime, toTime) {
        ws.send(
          JSON.stringify({
            type: "request_historical",
            from_time: fromTime,
            to_time: toTime,
          })
        );
      }

      // Function to initialize or update plot
      function updatePlot(trades) {
        if (trades && Array.isArray(trades)) {
          // Sort by timestamp just in case
          trades.sort((a, b) => a.timestamp - b.timestamp);
          tradeData.x = trades.map((trade) => new Date(trade.timestamp * 1000));
          tradeData.y = trades.map((trade) => trade.price);

          const trace = {
            x: tradeData.x,
            y: tradeData.y,
            mode: "lines+markers",
            type: "scatter",
            name: "Trade Prices",
          };
          const layout = {
            title: "Equity Price",
            xaxis: { title: "Time" },
            yaxis: { title: "Price" },
          };
          Plotly.newPlot("plot", [trace], layout);
        }
      }

      ws.onopen = function () {
        console.log("WebSocket connected");

        // On open, request initial data using saved or default range
        let fromTime = 0;
        let toTime = Math.floor(Date.now() / 1000);
        if (startDateInput.value) {
          fromTime = Math.floor(
            new Date(startDateInput.value).getTime() / 1000
          );
        }
        if (endDateInput.value) {
          toTime = Math.floor(new Date(endDateInput.value).getTime() / 1000);
        } else {
          toTime = Math.floor(Date.now() / 1000);
        }
        requestHistorical(fromTime, toTime);

        // Subscribe to real-time trades after historical
      };

      ws.onmessage = function (event) {
        const data = JSON.parse(event.data);
        console.log("Received message:", data); // Debug: Check what arrives

        if (data.type === "historical_trades") {
          updatePlot(data.trades);

          // Subscribe to real-time trades only after historical is processed
          ws.send(JSON.stringify({ type: "subscribe_trades" }));
        } else if (data.type === "new_trades") {
          // Append new trades if they fall within the current range
          const currentFrom = startDateInput.value
            ? new Date(startDateInput.value).getTime() / 1000
            : 0;
          const currentTo = endDateInput.value
            ? new Date(endDateInput.value).getTime() / 1000
            : Infinity;

          if (data.trades && Array.isArray(data.trades)) {
            const newX = [];
            const newY = [];
            for (const trade of data.trades) {
              if (
                trade.timestamp >= currentFrom &&
                trade.timestamp <= currentTo
              ) {
                tradeData.x.push(new Date(trade.timestamp * 1000));
                tradeData.y.push(trade.price);
                newX.push(new Date(trade.timestamp * 1000));
                newY.push(trade.price);
              }
            }

            if (newX.length > 0) {
              // Append to the existing trace (index 0, assuming single trace)
              Plotly.extendTraces("plot", { x: [newX], y: [newY] }, [0]);
            }
          }
        } else if (data.type === "order_book_update") {
          // Process order book update
          const state = data.data;
          // Aggregate quantities per price level

          let bidLevels = [];
          for (let priceStr in state.bids) {
            let price = parseFloat(priceStr);
            let totalQty = 0;
            for (let order of state.bids[priceStr]) {
              totalQty += parseFloat(order.quantity);
            }
            bidLevels.push({ price: price, quantity: totalQty });
          }
          bidLevels.sort((a, b) => b.price - a.price);
          const bids = bidLevels.slice(0, 10);

          let askLevels = [];
          for (let priceStr in state.asks) {
            let price = parseFloat(priceStr);
            let totalQty = 0;
            for (let order of state.asks[priceStr]) {
              totalQty += parseFloat(order.quantity);
            }
            askLevels.push({ price: price, quantity: totalQty });
          }
          askLevels.sort((a, b) => a.price - b.price);
          const asks = askLevels.slice(0, 10);

          const bid_prices = bids.map((b) => b.price);
          const bid_quantities = bids.map((b) => -b.quantity); // Negative for left side

          const ask_prices = asks.map((a) => a.price);
          const ask_quantities = asks.map((a) => a.quantity);

          const allQuantities = [
            ...bids.map((b) => b.quantity),
            ...asks.map((a) => a.quantity),
          ];
          const maxQty =
            allQuantities.length > 0 ? Math.max(...allQuantities) : 0;

          const trace1 = {
            y: bid_prices,
            x: bid_quantities,
            type: "bar",
            orientation: "h",
            marker: { color: "green" },
            name: "Bids",
            width: 0.1,
          };

          const trace2 = {
            y: ask_prices,
            x: ask_quantities,
            type: "bar",
            orientation: "h",
            marker: { color: "red" },
            name: "Asks",
            width: 0.1,
          };

          const layout = {
            title: "Market Depth",
            yaxis: { title: "Price" },
            xaxis: {
              title: "Quantity",
              range: [-maxQty * 1.1, maxQty * 1.1],
              tickmode: "array",
              showgrid: true,
            },
            showlegend: true,
            barmode: "overlay", // Since y positions differ
          };

          if (!orderBookPlotInitialized) {
            Plotly.newPlot("orderbook-plot", [trace1, trace2], layout);
            orderBookPlotInitialized = true;
          } else {
            Plotly.react("orderbook-plot", [trace1, trace2], layout);
          }
        }
      };

      // Apply range button listener
      applyButton.addEventListener("click", () => {
        const startValue = startDateInput.value;
        const endValue = endDateInput.value;

        // Save to localStorage for persistence
        if (startValue) {
          localStorage.setItem("startDate", startValue);
        } else {
          localStorage.removeItem("startDate");
        }
        if (endValue) {
          localStorage.setItem("endDate", endValue);
        } else {
          localStorage.removeItem("endDate");
        }

        let fromTime = 0;
        let toTime = Math.floor(Date.now() / 1000);
        if (startValue) {
          fromTime = Math.floor(new Date(startValue).getTime() / 1000);
        }
        if (endValue) {
          toTime = Math.floor(new Date(endValue).getTime() / 1000);
        } else {
          toTime = Math.floor(Date.now() / 1000);
        }

        // Request new historical data for the range
        requestHistorical(fromTime, toTime);
      });

      ws.onclose = function () {
        console.log("WebSocket disconnected");
      };

      ws.onerror = function (error) {
        console.error("WebSocket error:", error);
      };
    </script>
  </body>
</html>
