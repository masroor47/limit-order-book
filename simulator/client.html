<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stock Market Data Visualization Client</title>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #plot {
        width: 100%;
        height: 600px;
      }
      #orderbook-plot {
        width: 100%;
        height: 600px;
        display: none;
      }
      button {
        margin: 10px 0;
        padding: 10px;
      }
      .date-range {
        margin: 10px 0;
      }
      .date-range label {
        margin-right: 10px;
      }
      .date-range input {
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Bloomberg</h1>
    <div class="date-range">
      <label for="start-date">Start Date:</label>
      <input type="datetime-local" id="start-date" />
      <label for="end-date">End Date:</label>
      <input type="datetime-local" id="end-date" />
      <button id="apply-range">Apply Range</button>
    </div>
    <div>
      <label for="tick-size">Tick Size:</label>
      <select id="tick-size">
        <option value="10">10s</option>
        <option value="30">30s</option>
        <option value="60">1m</option>
        <option value="1800">30m</option>
        <option value="3600">1h</option>
      </select>
    </div>
    <div id="plot"></div>
    <button id="toggle-orderbook">Show Order Book</button>
    <div id="orderbook-plot"></div>
    <script>
      // Helper function to format date for datetime-local
      function formatDateTimeLocal(date) {
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, "0");
        const dd = String(date.getDate()).padStart(2, "0");
        const hh = String(date.getHours()).padStart(2, "0");
        const min = String(date.getMinutes()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
      }

      // Initialize WebSocket connection
      const ws = new WebSocket("ws://127.0.0.1:8766");

      // Data storage for trades (assuming trades have 'timestamp' and 'price' fields)
      let tradeData = {
        x: [], // timestamps (converted to Date objects)
        y: [], // prices
      };

      // For order book
      let subscribedOrderBook = false;
      let orderBookPlotInitialized = false;
      const toggleButton = document.getElementById("toggle-orderbook");
      let showOrderBook = false;

      toggleButton.addEventListener("click", () => {
        showOrderBook = !showOrderBook;
        if (showOrderBook) {
          if (!subscribedOrderBook) {
            ws.send(JSON.stringify({ type: "subscribe_order_book" }));
            subscribedOrderBook = true;
          }
          document.getElementById("orderbook-plot").style.display = "block";
          toggleButton.textContent = "Hide Order Book";
        } else {
          if (subscribedOrderBook) {
            ws.send(JSON.stringify({ type: "unsubscribe_order_book" }));
            subscribedOrderBook = false;
          }
          document.getElementById("orderbook-plot").style.display = "none";
          toggleButton.textContent = "Show Order Book";
        }
      });

      // Date range elements
      const startDateInput = document.getElementById("start-date");
      const endDateInput = document.getElementById("end-date");
      const tickSizeSelect = document.getElementById("tick-size");
      const applyButton = document.getElementById("apply-range");

      // Load persistent range from localStorage
      const savedStart = localStorage.getItem("startDate");
      const savedEnd = localStorage.getItem("endDate");
      const savedTickSize = localStorage.getItem("tickSize");

      if (savedStart) {
        startDateInput.value = savedStart;
      }
      if (savedEnd) {
        endDateInput.value = savedEnd;
      }
      if (savedTickSize) {
        tickSizeSelect.value = savedTickSize;
      }

      // Set default start if not saved (market open today or previous day)
      if (!startDateInput.value) {
        const now = new Date();
        let marketOpen = new Date(
          now.getFullYear(),
          now.getMonth(),
          now.getDate(),
          9,
          30,
          0,
          0
        );
        if (marketOpen > now) {
          marketOpen.setDate(marketOpen.getDate() - 1);
        }
        startDateInput.value = formatDateTimeLocal(marketOpen);
      }

      // Function to request data for a given range
      function requestHistorical(fromTime, toTime) {
        ws.send(
          JSON.stringify({
            type: "request_historical",
            from_time: fromTime,
            to_time: toTime,
          })
        );
      }

      // Function to request OHLCV data
      function requestOHLCV(fromTime, toTime, tickSize) {
        ws.send(
          JSON.stringify({
            type: "request_historical_ohlc",
            from_time: fromTime,
            to_time: toTime,
            tick_size: tickSize,
          })
        );
      }

      // Function to initialize or update plot
      function updatePlot(trades) {
        if (trades && Array.isArray(trades)) {
          // Sort by timestamp just in case
          trades.sort((a, b) => a.timestamp - b.timestamp);
          tradeData.x = trades.map((trade) => new Date(trade.timestamp * 1000));
          tradeData.y = trades.map((trade) => trade.price);

          const trace = {
            x: tradeData.x,
            y: tradeData.y,
            mode: "lines+markers",
            type: "scatter",
            name: "Trade Prices",
          };
          const layout = {
            title: "Equity Price",
            xaxis: { title: "Time" },
            yaxis: { title: "Price" },
          };
          Plotly.newPlot("plot", [trace], layout);
        }
      }

      // Function to initialize or update OHLCV plot
      function updateOHLCVPlot(data) {
        const times = data.map((d) => new Date(d.time * 1000)); // Convert back to Date
        const opens = data.map((d) => d.open);
        const highs = data.map((d) => d.high);
        const lows = data.map((d) => d.low);
        const closes = data.map((d) => d.close);
        const volumes = data.map((d) => d.volume);
        const tickSize = parseInt(tickSizeSelect.value);
        Plotly.newPlot(
          "plot",
          [
            {
              type: "candlestick",
              x: times,
              open: opens,
              high: highs,
              low: lows,
              close: closes,
              name: "Price",
              increasing: { line: { color: "green" } }, // Optional: Color up candles green
              decreasing: { line: { color: "red" } }, // Optional: Color down candles red
            },
            {
              type: "bar",
              x: times,
              y: volumes,
              name: "Volume",
              yaxis: "y2",
              marker: { color: "blue" }, // Optional: Style volume bars
            },
          ],
          {
            // Corrected: No outer 'layout' keyâ€”just the properties directly
            title: "OHLCV Chart",
            xaxis: {
              title: "Time",
              rangeslider: { visible: true }, // Optional: Add zoom slider
            },
            yaxis: {
              title: "Price",
              domain: [0.25, 1], // Adjusted slightly for better spacing; top 75%
            },
            yaxis2: {
              title: "Volume",
              domain: [0, 0.2], // Bottom 20% for volume
              showgrid: false,
              overlaying: false, // Ensure it's a true subplot, not overlay
            },
            height: 600, // Optional: Set explicit height to avoid resizing issues
            margin: { t: 50, b: 50, l: 50, r: 50 }, // Optional: Adjust margins
          }
        );
        currentBucket = Math.floor(Date.now() / 1000 / tickSize) * tickSize; // Track for real-time
        currentCandle = {
          open: data[data.length - 1]?.close || null,
          high: null,
          low: null,
          close: null,
          volume: 0,
        };
      }

      ws.onopen = function () {
        console.log("WebSocket connected");

        // On open, request initial data using saved or default range
        // let fromTime = 0;
        // let toTime = Math.floor(Date.now() / 1000);
        // if (startDateInput.value) {
        //   fromTime = Math.floor(
        //     new Date(startDateInput.value).getTime() / 1000
        //   );
        // }
        // if (endDateInput.value) {
        //   toTime = Math.floor(new Date(endDateInput.value).getTime() / 1000);
        // } else {
        //   toTime = Math.floor(Date.now() / 1000);
        // }
        let startValue = startDateInput.value;
        let endValue = endDateInput.value;
        let tickSizeValue = parseInt(tickSizeSelect.value);
        if (startValue) {
          fromTime = convertDateToTimestamp(startValue);
        }
        if (endValue) {
          toTime = convertDateToTimestamp(endValue);
        } else {
          toTime = Math.floor(Date.now() / 1000);
        }
        // requestHistorical(fromTime, toTime);
        requestOHLCV(fromTime, toTime, tickSizeValue);

        // Subscribe to real-time trades after historical
      };

      ws.onmessage = function (event) {
        const data = JSON.parse(event.data);
        console.log("Received message:", data); // Debug: Check what arrives

        if (data.type === "historical_trades") {
          updatePlot(data.trades);
          // Subscribe to real-time trades only after historical is processed
          ws.send(JSON.stringify({ type: "subscribe_trades" }));
        } else if (data.type == "historical_ohlc") {
          updateOHLCVPlot(data.data);
          // Subscribe to real-time OHLCV updates
          ws.send(JSON.stringify({ type: "subscribe_trades" }));
        } else if (data.type === "new_trades") {
          data.trades.forEach((trade) => {
            const tickSize = parseInt(tickSizeSelect.value);
            const bucket = Math.floor(trade.timestamp / tickSize) * tickSize;
            if (bucket > currentBucket) {
              // Finalize old candle, start new (add to Plotly with Plotly.extendTraces)
              Plotly.extendTraces(
                "chart",
                {
                  x: [[new Date(currentBucket * 1000)]],
                  open: [[currentCandle.open]] /* etc */,
                },
                [0]
              );
              Plotly.extendTraces(
                "chart",
                {
                  x: [[new Date(currentBucket * 1000)]],
                  y: [[currentCandle.volume]],
                },
                [1]
              );
              currentBucket = bucket;
              currentCandle = {
                open: trade.price,
                high: trade.price,
                low: trade.price,
                close: trade.price,
                volume: trade.quantity,
              };
            } else {
              // Update current
              if (!currentCandle.open) currentCandle.open = trade.price;
              currentCandle.high = Math.max(
                currentCandle.high || trade.price,
                trade.price
              );
              currentCandle.low = Math.min(
                currentCandle.low || trade.price,
                trade.price
              );
              currentCandle.close = trade.price;
              currentCandle.volume += trade.quantity;
              // React to Plotly: Plotly.react('chart', /* updated data */);
            }
          });
          // } else if (data.type === "new_trades") {
          //   // Append new trades if they fall within the current range
          //   const currentFrom = startDateInput.value
          //     ? new Date(startDateInput.value).getTime() / 1000
          //     : 0;
          //   const currentTo = endDateInput.value
          //     ? new Date(endDateInput.value).getTime() / 1000
          //     : Infinity;

          //   if (data.trades && Array.isArray(data.trades)) {
          //     const newX = [];
          //     const newY = [];
          //     for (const trade of data.trades) {
          //       if (
          //         trade.timestamp >= currentFrom &&
          //         trade.timestamp <= currentTo
          //       ) {
          //         tradeData.x.push(new Date(trade.timestamp * 1000));
          //         tradeData.y.push(trade.price);
          //         newX.push(new Date(trade.timestamp * 1000));
          //         newY.push(trade.price);
          //       }
          //     }

          //     if (newX.length > 0) {
          //       // Append to the existing trace (index 0, assuming single trace)
          //       Plotly.extendTraces("plot", { x: [newX], y: [newY] }, [0]);
          //     }
          // }
        } else if (data.type === "order_book_update") {
          // Process order book update
          const state = data.data;
          // Aggregate quantities per price level

          let bidLevels = [];
          for (let priceStr in state.bids) {
            let price = parseFloat(priceStr);
            let totalQty = 0;
            for (let order of state.bids[priceStr]) {
              totalQty += parseFloat(order.quantity);
            }
            bidLevels.push({ price: price, quantity: totalQty });
          }
          bidLevels.sort((a, b) => b.price - a.price);
          const bids = bidLevels.slice(0, 10);

          let askLevels = [];
          for (let priceStr in state.asks) {
            let price = parseFloat(priceStr);
            let totalQty = 0;
            for (let order of state.asks[priceStr]) {
              totalQty += parseFloat(order.quantity);
            }
            askLevels.push({ price: price, quantity: totalQty });
          }
          askLevels.sort((a, b) => a.price - b.price);
          const asks = askLevels.slice(0, 10);

          const bid_prices = bids.map((b) => b.price);
          const bid_quantities = bids.map((b) => -b.quantity); // Negative for left side

          const ask_prices = asks.map((a) => a.price);
          const ask_quantities = asks.map((a) => a.quantity);

          const allQuantities = [
            ...bids.map((b) => b.quantity),
            ...asks.map((a) => a.quantity),
          ];
          const maxQty =
            allQuantities.length > 0 ? Math.max(...allQuantities) : 0;

          const trace1 = {
            y: bid_prices,
            x: bid_quantities,
            type: "bar",
            orientation: "h",
            marker: { color: "green" },
            name: "Bids",
            width: 0.1,
          };

          const trace2 = {
            y: ask_prices,
            x: ask_quantities,
            type: "bar",
            orientation: "h",
            marker: { color: "red" },
            name: "Asks",
            width: 0.1,
          };

          const layout = {
            title: "Market Depth",
            yaxis: { title: "Price" },
            xaxis: {
              title: "Quantity",
              range: [-maxQty * 1.1, maxQty * 1.1],
              tickmode: "array",
              showgrid: true,
            },
            showlegend: true,
            barmode: "overlay", // Since y positions differ
          };

          if (!orderBookPlotInitialized) {
            Plotly.newPlot("orderbook-plot", [trace1, trace2], layout);
            orderBookPlotInitialized = true;
          } else {
            Plotly.react("orderbook-plot", [trace1, trace2], layout);
          }
        }
      };

      // Apply range button listener
      applyButton.addEventListener("click", () => {
        const startValue = startDateInput.value;
        const endValue = endDateInput.value;
        const tickSizeValue = parseInt(tickSizeSelect.value);
        console.log("applyRange clicked with values:", {
          startValue,
          endValue,
          tickSizeValue,
        });

        // Save to localStorage for persistence
        if (startValue) {
          localStorage.setItem("startDate", startValue);
        } else {
          localStorage.removeItem("startDate");
        }
        if (endValue) {
          localStorage.setItem("endDate", endValue);
        } else {
          localStorage.removeItem("endDate");
        }
        if (tickSizeValue) {
          localStorage.setItem("tickSize", tickSizeValue);
        } else {
          localStorage.removeItem("tickSize");
        }

        let fromTime = 0;
        let toTime = Math.floor(Date.now() / 1000);
        if (startValue) {
          fromTime = convertDateToTimestamp(startValue);
          // fromTime = Math.floor(new Date(startValue).getTime() / 1000);
        }
        if (endValue) {
          toTime = convertDateToTimestamp(endValue);
          // toTime = Math.floor(new Date(endValue).getTime() / 1000);
        } else {
          toTime = Math.floor(Date.now() / 1000);
        }

        // Request new historical data for the range
        // requestHistorical(fromTime, toTime);
        requestOHLCV(fromTime, toTime, tickSizeValue);
      });

      function convertDateToTimestamp(dateString) {
        const date = new Date(dateString);
        return Math.floor(date.getTime() / 1000); // Convert to seconds
      }

      ws.onclose = function () {
        console.log("WebSocket disconnected");
      };

      ws.onerror = function (error) {
        console.error("WebSocket error:", error);
      };
    </script>
  </body>
</html>
